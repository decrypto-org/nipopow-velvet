\section{Preliminaries}

We consider a setting where the blockchain network consists of two different
types of nodes: The first kind, \emph{full nodes}, are responsible for the
maintenance of the chain including verifying it and mining new blocks. The
second kind, \emph{verifiers} connect to full nodes and wish to learn facts
about the blockchain without downloading it, for example whether a particular
transaction is confirmed. The full nodes therefore also function as
\emph{provers} for the verifiers. Each verifier connects to multiple provers, at
least one of which is assumed to be honest.

We model full nodes according to the Backbone model~\cite{backbone}. There are
$n$ full nodes, of which $t$ are adversarial and $n - t$ are honest. All $t$
adversarial parties are controlled by one colluding adversary $\mathcal{A}$. The
parties have access to a hash function $H$ which is modelled as a common Random
Oracle~\cite{ro}. To each novel query, the random oracle outputs $\kappa$ bits
of fresh randomness. Time is split into distinct \emph{rounds} numbered by the
integers $1, 2, \cdots$. Our treatment is in the \emph{synchronous model}, so we
assume messages \emph{diffused} (broadcast) by an honest party at the end of a
round are received by all honest parties at the beginning of the next round.
This is equivalent to a network connectivity assumption in which the round
duration is taken to be the known time needed for a message to cross the
diameter of the network.

Each honest full node locally maintains a \emph{chain} $\chain$, a sequence of
blocks. In understanding that we are developing an improvement on top of SPV, we
use the term \emph{block} to mean what is typically referred to as a
\emph{block header}. Each block contains the Merkle Tree root of transaction
data $\overline{x}$, the hash $s$ of the previous block in the chain known as
the previd, as well as a nonce value $ctr$. As discussed in the Introduction,
the compression of application data $\overline{x}$ is orthogonal to our goals in
this paper and has been explored in independent work~\cite{edrax} which can be
composed with ours. Each block $b = s \conc \overline{x} \conc ctr$ must
satisfy the proof-of-work equation $H(b) \leq T$ where $T$ is a constant
\emph{target}, a small value signifying the difficulty of the proof-of-work
problem. Our treatment is in the \emph{static difficulty} case, so we assume
that $T$ is constant throughout the execution. $H(B)$ is known as the
\emph{block id}.

Blockchains are finite block sequences obeying the \emph{blockchain property}:
that in every block in the chain there exists a pointer to its previous block. A
chain is \emph{anchored} if its first block is \emph{genesis}, denoted $Gen$,
a special block known to all parties. This is the only node the verifier has
when it boots up. For chain addressing we use Python brackets $\chain[\cdot]$. A
zero-based positive number in a bracket indicates the indexed block in the
chain. A negative index indicates a block from the end, e.g., $\chain[-1]$ is
the tip of the blockchain. A range $\chain[i{:}j]$ is a subarray starting from
$i$ (inclusive) to j (exclusive). Given chains $\chain_1, \chain_2$ and blocks
$A, Z$ we concatenate them as $\chain_1 \chain_2$ or $\chain_1 A$. Here,
$\chain_2[0]$ must point to $\chain_1[-1]$ and $A$ must point to $\chain_1[-1]$.
We denote $\chain\{A{:}Z\}$ the subarray of the chain from $A$ (inclusive) to
$Z$ (exclusive). We can omit blocks or indices from either side of the range to
take the chain to the beginning or end respectively.

During every round, every party attempts to \emph{mine} a new block on top of
its currently adopted chain. Each party is given $q$ queries to the random
oracle which it uses in attempting to mine a new block. Therefore the adversary
has $tq$ queries per round while the honest parties have $(n - t)q$ queries per
round. When an honest party discovers a new block, they extend their chain with
it and broadcast the new chain. Upon receiving a new chain $\chain'$ from the
network, an honest party compares its length $|\chain'|$ against its currently
adopted chain $\chain$ and adopts the newly received chain if it is longer.

Some valid blocks satisfy the proof-of-work equation better than required. If
a block $b$ satisfies $H(b) \leq 2^{-\mu} T$ for some natural number
$\mu \in \mathbb{N}$ we say that $b$ is a \emph{$\mu$-superblock} or a block
\emph{of level} $\mu$. The probability of a new valid block achieving level
$\mu$ is $2^{-\mu}$.
