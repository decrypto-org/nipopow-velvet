\section{Velvet NIPoPoWs}\label{sec:construction}
In order to eliminate the Chainsewing Attack we propose an update to the velvet NIPoPoW protocol. The core problem is that, in her suffix proof, the adversary was able to claim not only blocks of shorter forked chains, but also arbitrarily long parts of the chain generated by an honest party. Since thorny blocks are accepted as valid, the verifier cannot distinguish blocks that actually belong in a chain from blocks that only \emph{seem} to belong in the same chain because they are pointed to from a thorny block.

The idea for a secure protocol is to distinguish the smooth from the thorny blocks, so that smooth blocks can never point to thorny blocks. In this way we can make sure that thorny blocks acting as passing points to fork chains, as block $a'$ does in Figure~\ref{fig:attack}, cannot be pointed to by honestly generated blocks. Therefore, the adversary cannot utilize honest mining power to construct a stronger suffix proof for her fork chain. Our velvet construction mandates that honest miners create blocks that contain interlink pointers pointing only to previous smooth blocks. As such, newly created smooth blocks can only point to previously created smooth blocks and not thorny blocks. Following the terminology of Section~\ref{sec:velvet}, the smoothness of a block in this new construction is a stricter notion than smoothness in the na\"ive construction.

In order to formally describe the suggested protocol patch, we define smooth blocks in our patched protocol recursively by introducing the notion of a smooth interlink pointer.

\begin{definition}[Smooth Pointer]
  A \emph{smooth pointer} of a block $b$ for a specific level $\mu$ is the interlink pointer to the most recent $\mu$-level smooth ancestor of $b$.
	\label{defn:smooth_pointer}
\end{definition}

We describe a protocol patch that operates as follows. The superblock NIPoPoW protocol works as usual but each honest miner constructs smooth blocks whose interlink contains only smooth pointers; thus it is constructed excluding thorny blocks. In this way, although thorny blocks are accepted in the chain, they are not taken into consideration when updating the interlink structure for the next block to be mined. No honest block could now point to a thorny superblock that may act as a passage to the fork chain in an adversarial suffix proof. Thus, after this protocol update, the adversary is only able to inject \emph{adversarially} generated blocks from an honestly adopted chain to her own fork.
At the same time, thorny blocks cannot participate in an honestly generated suffix proof except for some blocks in the proof's suffix $(\chi)$. Consequently, as far as the blocks included in a suffix proof are concerned, we can think of thorny blocks as belonging in the adversary's fork chain for the $\pi$ part of the proof,  which is the critical part for proof comparison.
Figure~\ref{fig:injection} illustrates this remark. The velvet NIPoPoW verifier is also modified to only follow interlink pointers, and never previd pointers (which could be pointing to thorny blocks, even if honestly generated).

\begin{figure*}[h!]
	\begin{center}
		\iftwocolumn
			\includegraphics[width=0.8 \textwidth]{figures/injection.pdf}
		\else
			\includegraphics[width=0.8 \textwidth]{figures/injection.pdf}
		\fi
	\end{center}
	\caption{The adversarial fork chain $\chain_\mathcal{A}$ and chain $\chain_B$ of an honest party. Thorny blocks are colored black. Dashed arrows represent interlink pointers. Wavy lines imply one or more blocks. After the protocol update, when an adversarially generated block is sewed from $\chain_B$ into the adversary's suffix proof the verifier perceives $\chain_\mathcal{A}$ as longer and $\chain_B$ as shorter. \textbf{I:} The real picture of the chains. \textbf{II:} Equivalent picture from the verifier's perspective considering the blocks included in the corresponding suffix proof for each chain.}
	\label{fig:injection}
\end{figure*}

With this protocol patch we conclude that the adversary cannot usurp honest mining power for use in her fork chain. This change has an undesired side effect: the honest prover cannot utilize thorny blocks belonging in the honest chain. Thus, contrary to the na\"ive protocol, the honest prover can only depend on \emph{honestly} mined blocks in the honestly adopted chain. Due to this fact, to ensure security in the velvet model, we introduce the assumption that the adversary is bound by $1/3$ of the honest \emph{upgraded} mining power.

\begin{definition}[Velvet Honest Majority]
	Let $n_h$ be the number of upgraded honest miners. Then $t$ out of total $n$ parties are corrupted such that $\dfrac{t}{n_h} < \dfrac{1 - \delta_v}{3}$, for some $\delta_v > 0$.
	\label{defn:velvet_honest_majority}
\end{definition}

The following Lemmas come as immediate results from the suggested protocol
update.

\begin{lemma}
	A velvet suffix proof constructed by an honest party cannot contain any thorny block.
	\label{lemm:smooth_honest_suffix}
\end{lemma}
%\begin{proof}
%	The statement holds by construction.
%\end{proof}

\begin{lemma}
	Let $\mathcal{P_A} = (\pi_\mathcal{A}, \chi_\mathcal{A})$ be a velvet suffix proof constructed by the adversary and block $b_s$, generated at round $r_s$, be the most recent smooth block in the proof. Then no thorny blocks generated at round $r < r_s$ can be included in $\mathcal{P_A}$.
	\label{lemm:smooths_before_smooth}
\end{lemma}
\begin{proof}
By contradiction. Let $b_t$ be a thorny block generated at some round $r_t < r_s$. Suppose for contradiction that $b_t$ is included in the proof. Then, because $\mathcal{P_A}$ is a valid chain in terms of interlink pointers, there exists an interlink path from $b_s$ to $b_t$ (the blocks must appear in the proof in this order, because $b_t$ cannot contain a pointer path to $b_s$, as $b_t$ was generated prior to $b_s$). Let $b'$ be the most recently generated thorny block after $b_t$ and before $b_s$ included in $\mathcal{P_A}$ (if no such block exists, then let $b' = b_t$). Then $b'$ has been generated at a round $r'$ such that $r_t \leq r' < r_s$. Then the block right after $b'$ in $\mathcal{P_A}$ must be thorny since it points to $b'$ which is thorny. But $b'$ is the most recent thorny block after $b_t$, thus we have reached a contradiction.
\qed
\end{proof}

\begin{lemma}
	Let $\mathcal{P_A} = (\pi_\mathcal{A}, \chi_\mathcal{A})$ be a velvet suffix proof constructed by the adversary. Let $b_t$ be the oldest thorny bock included in $\mathcal{P_A}$ which is generated at round $r_t$. Then any block $b = \{b: b \in \mathcal{P_A} \wedge \text{b generated at }r \geq r_t \}$ is thorny.
	\label{lemm:thorny_after_thorny}
\end{lemma}
\begin{proof}
By contradiction. Suppose for contradiciton that $b_s$ is a smooth block generated at round $r_s > r_t$. Then from Lemma \ref{lemm:smooths_before_smooth} any block generated at round $r < r_s$ is smooth. But $b_t$ is generated at round $r_t < r_s$ and is thorny, thus we have reached a contradiction.
\qed
\end{proof}

The following corollary emerges immediately from Lemmas~\ref{lemm:smooths_before_smooth} and~\ref{lemm:thorny_after_thorny}. This result is illustrated in Figure~\ref{fig:adversarial_velvet_proof}.

\begin{corollary}
	Any adversarial proof $\mathcal{P_A} = (\pi_\mathcal{A}, \chi_\mathcal{A})$ containing both smooth and thorny blocks consists of a prefix smooth subchain followed by a suffix thorny subchain.
	\label{cor:adversarial_proof_scheme}
\end{corollary}

\begin{figure}[h!]
	\begin{center}
		\iftwocolumn
			\includegraphics[width=0.9\columnwidth]{figures/adversarial_velvet_proof.pdf}
		\else
			\includegraphics[width=0.5\columnwidth]{figures/adversarial_velvet_proof.pdf}
		\fi
	\end{center}
	\caption{General case of the adversarial velvet suffix proof $\mathcal{P_A} = (\pi_\mathcal{A}, \chi_\mathcal{A})$ consisting of an initial part of smooth blocks followed by thorny blocks.}
	\label{fig:adversarial_velvet_proof}
\end{figure}
We now describe the algorithms needed by the upgraded miner, prover and verifier. In order to construct an interlink containing only the smooth blocks, the miner keeps a copy of the ``smooth chain'' ($\chain_S$) which consists of the smooth blocks in his adopted chain $\chain$. The algorithm for extracting the smooth chain out of $\chain$ is given in Algorithm~\ref{alg:smooth_chain_suffix}. Function \emph{isSmoothBlock($B$)} checks whether a block $B$ is smooth by calling \textit{isSmoothPointer($B,p$)} for every pointer $p$ in $B$'s interlink. Function \emph{isSmoothPointer($B,p$)} returns \emph{true} if $p$ is a valid pointer, i.e., a pointer to the most recent smooth block for the level denoted by the pointer itself. The \emph{updateInterlink} algorithm is given in Algorithm~\ref{alg:updateInterlink}. It is the same as in the case of a soft fork, but works on the smooth chain $\chain_S$ instead of $\chain$.

The construction of the velvet suffix prover is given in Algorithm~\ref{alg:velvet_suffix_prover}. Again it deviates from the soft fork case by working on the smooth chain $\chain_S$ instead of $\chain$.
Lastly, the Verify algorithm for the NIPoPoW suffix protocol remains the same as in the case of a hard or soft fork, keeping in mind that no \emph{previd} links can be followed when verifying the ancestry of the chain to avoid hitting any thorny blocks.

\begin{algorithm}[h]
	\caption{\label{alg:smooth_chain_suffix}Smooth chain for suffix proofs}
	\begin{algorithmic}[1]
			\Function{\sf smoothChain}{$\chain$}
				\Let{\chain_S}{\{\mathcal{G}\}}
				\Let{k}{1}
				\While{$\chain[-k] \neq \mathcal{G}$}
						\If{$\textsf{isSmoothBlock}(\chain[-k])$}
							\Let{\chain_S}{\chain_S \cup \chain[-k]}
						\EndIf
						\Let{k}{k + 1}
				\EndWhile
				\State\Return{$\chain_S$}
			\EndFunction

			\Function{\sf isSmoothBlock}{$B$}
				\If{$B = \mathcal{G}$}
					\State\Return{$\true$}
				\EndIf
				\For{$p \in B.\textsf{interlink}$}
						\If{$\lnot \textsf{isSmoothPointer}(B, p)$}
							\State\Return{$\false$}
						\EndIf
				\EndFor
				\State\Return{$\true$}
			\EndFunction

			\Function{\sf isSmoothPointer}{$B, p$}
				\Let{b}{\textsf{Block}(B.\textsf{prevId})}
				\While{$b \neq p$}
						\If{$\textsf{level}(b) \geq \textsf{level}(p) \land \textsf{isSmoothBlock}(b)$}
							\State\Return{$\false$}
						\EndIf
						\If{$b = \mathcal{G}$}
							\State\Return{$\false$}
						\EndIf
						\Let{b}{\textsf{Block}(b.\textsf{prevId})}
				\EndWhile
				\State\Return{$\textsf{isSmoothBlock}(b)$}
			\EndFunction
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
		\caption{\label{alg:updateInterlink}Velvet updateInterlink}
		\begin{algorithmic}[1]
				\Function{\sf updateInterlinkVelvet}{$\chain_S$}
						\Let{B'}{\chain_S[-1]}
						\Let{\textsf{interlink}}{B'.\textsf{interlink}}
						\For{$\mu = 0$ to $\textsf{level}(B')$}
								\Let{\textsf{interlink}[\mu]}{\textsf{id}(B')}
						\EndFor
						\State\Return$\textsf{interlink}$
				\EndFunction
		\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
		\caption{\label{alg:velvet_suffix_prover}Velvet Suffix Prover}
		\begin{algorithmic}
				\Function{\sf ProveVelvet$_{m,k}$}{$\chain_S$}
					\Let{B}{\chain_S[0]}
					\For{$\mu = \lvert \chain_S[-k].\textsf{interlink} \rvert$ down to $0$}
						\Let{\alpha}{\chain_S[{:}-k]\{B{:}\}\upchain^\mu}
						\Let{\pi}{\pi \cup \alpha}
						\Let{B}{\alpha[-m]}
					\EndFor
					\Let{\chi}{\chain_S[-k{:}]}
					\State\Return$\pi\chi$
				\EndFunction
		\end{algorithmic}
\end{algorithm}
